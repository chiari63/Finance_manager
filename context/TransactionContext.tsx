import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { 
  Transaction, 
  FinancialSummary, 
  CategorySummary, 
  MonthlyData, 
  BalanceAccount,
  ManualBill
} from '@/types/TransactionTypes';
import { 
  TransactionFrequency, 
  TransactionType, 
  CATEGORIES,
  Category
} from '@/constants/Categories';
import { PaymentMethod } from '@/types/TransactionTypes';
import { auth, db } from '@/config/firebase';
import { 
  collection, 
  addDoc, 
  doc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  getDocs, 
  Timestamp, 
  serverTimestamp,
  onSnapshot,
  setDoc,
  getDoc
} from 'firebase/firestore';
import { useAuth } from './AuthContext';

interface TransactionContextProps {
  currentMonth: { month: number; year: number };
  transactions: Transaction[];
  financialSummary: FinancialSummary;
  categorySummaries: CategorySummary[];
  accounts: BalanceAccount[];
  installedPayments: Transaction[];
  paymentMethods: PaymentMethod[];
  isLoading: boolean;
  error: string | null;
  
  // A√ß√µes
  addTransaction: (transaction: Omit<Transaction, 'id'>) => Promise<void>;
  updateTransaction: (transaction: Transaction) => Promise<void>;
  deleteTransaction: (id: string) => Promise<void>;
  filterTransactionsByCategory: (categoryId: string) => Transaction[];
  filterTransactionsByType: (type: TransactionType) => Transaction[];
  filterTransactionsByFrequency: (frequency: TransactionFrequency) => Transaction[];
  changeMonth: (month: number, year: number) => void;
  addAccount: (account: Omit<BalanceAccount, 'id'>) => Promise<void>;
  updateAccount: (account: BalanceAccount) => Promise<void>;
  deleteAccount: (id: string) => Promise<void>;
  loadAccounts: () => Promise<unknown>;
  loadPaymentMethods: () => Promise<unknown>;
  clearTransactions: () => Promise<void>;
  addManualBill: (bills: ManualBill[]) => Promise<void>;
}

// Resumo financeiro inicial vazio
const initialSummary: FinancialSummary = {
  totalBalance: 0,
  monthlyExpenses: 0,
  monthlyIncome: 0,
  cashBalance: 0,
  foodVoucherBalance: 0,
  fixedExpenses: 0,
  variableExpenses: 0,
  foodVoucherExpenses: 0
};

// Dados de exemplo para modo offline/desenvolvimento
const mockTransactions: any[] = [
  {
    id: 'mock-transaction-1',
    title: 'Sal√°rio',
    amount: 3000,
    type: TransactionType.INCOME,
    categoryId: 'salary',
    category: CATEGORIES.find(c => c.id === 'salary'),
    date: new Date(),
    paymentMethodId: 'transfer',
    account: {
      id: 'mock-account-1',
      name: 'Conta Corrente',
      type: 'bank'
    },
    frequency: TransactionFrequency.FIXED,
    description: 'Sal√°rio mensal',
    createdAt: new Date()
  },
  {
    id: 'mock-transaction-2',
    title: 'Mercado',
    amount: 250,
    type: TransactionType.EXPENSE,
    categoryId: 'food',
    category: CATEGORIES.find(c => c.id === 'food'),
    date: new Date(),
    paymentMethodId: 'credit',
    account: {
      id: 'mock-account-1',
      name: 'Conta Corrente',
      type: 'bank'
    },
    frequency: TransactionFrequency.VARIABLE,
    description: 'Compras da semana',
    createdAt: new Date()
  }
];

const mockAccounts: BalanceAccount[] = [
  {
    id: 'mock-account-1',
    name: 'Conta Corrente',
    balance: 2750,
    type: 'bank',
    color: '#2196F3',
    icon: 'bank'
  },
  {
    id: 'mock-account-2',
    name: 'Carteira',
    balance: 150,
    type: 'cash',
    color: '#4CAF50',
    icon: 'wallet'
  },
  {
    id: 'mock-account-3',
    name: 'Vale-Alimenta√ß√£o',
    balance: 300,
    type: 'voucher',
    color: '#FF9800',
    icon: 'food'
  }
];

const TransactionContext = createContext<TransactionContextProps | undefined>(undefined);

// Helpers para converter do Firestore
const convertFirestoreTimestampToDate = (timestamp: any): Date => {
  if (!timestamp) return new Date();
  if (timestamp instanceof Date) return timestamp;
  if (timestamp.toDate && typeof timestamp.toDate === 'function') {
    return timestamp.toDate();
  }
  return new Date(timestamp.seconds * 1000);
};

// Converter documento do Firestore para Transaction
const convertToTransaction = (doc: any): Transaction => {
  const data = doc.data();
  const category = CATEGORIES.find(c => c.id === data.categoryId);
  
  return {
    id: doc.id,
    title: data.title,
    amount: data.amount,
    type: data.type as TransactionType,
    categoryId: data.categoryId,
    paymentMethodId: data.paymentMethodId || null,
    accountId: data.accountId || null,
    date: convertFirestoreTimestampToDate(data.date),
    frequency: data.frequency as TransactionFrequency,
    description: data.description || '',
    installment: data.installment ? {
      ...data.installment,
      startDate: convertFirestoreTimestampToDate(data.installment.startDate)
    } : undefined,
    isManualBill: data.isManualBill || false,
  };
};

// Converter documento do Firestore para BalanceAccount
const convertToAccount = (doc: any): BalanceAccount => {
  const data = doc.data();
  return {
    id: doc.id,
    name: data.name,
    balance: data.balance,
    type: data.type,
    color: data.color,
    icon: data.icon
  };
};

export function TransactionProvider({ children }: { children: ReactNode }) {
  const { user } = useAuth();
  const [currentMonth, setCurrentMonth] = useState<{ month: number; year: number }>({
    month: new Date().getMonth(),
    year: new Date().getFullYear()
  });
  
  const [monthlyData, setMonthlyData] = useState<MonthlyData[]>([]);
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [financialSummary, setFinancialSummary] = useState<FinancialSummary>(initialSummary);
  const [categorySummaries, setCategorySummaries] = useState<CategorySummary[]>([]);
  const [accounts, setAccounts] = useState<BalanceAccount[]>([]);
  const [installedPayments, setInstalledPayments] = useState<Transaction[]>([]);
  const [paymentMethods, setPaymentMethods] = useState<PaymentMethod[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Carregar dados de mock para modo de desenvolvimento (offline)
  const loadMockData = useCallback(() => {
    console.log('üì± Carregando dados de exemplo para modo offline');
    setTransactions(mockTransactions);
    setAccounts(mockAccounts);
    updateSummaries(mockTransactions);
    updateAccountBalances(mockAccounts);
    setIsLoading(false);
  }, []);

  // Carregar contas do usu√°rio
  const loadAccounts = useCallback(async () => {
    if (!user) return;
    
    try {
      console.log('üîÑ Carregando contas do Firebase');
      const accountsCollectionRef = collection(db, 'users', user.id, 'bankAccounts');
      
      // Usar onSnapshot para atualiza√ß√£o em tempo real
      return onSnapshot(accountsCollectionRef, (snapshot) => {
        const accountsList = snapshot.docs.map(convertToAccount);
        setAccounts(accountsList);
        
        // Atualizar o resumo financeiro com base nas contas
        updateAccountBalances(accountsList);
      }, (error) => {
        console.error('Erro ao observar contas:', error);
      });
    } catch (error) {
      console.error('Erro ao carregar contas:', error);
    }
  }, [user]);

  // Definir loadInstallments antes de ser usado em loadTransactions
  const loadInstallments = useCallback(async () => {
    if (!user) return;
    
    try {
      console.log('üîÑ Carregando parcelas do Firebase');
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      const q = query(
        transactionsCollectionRef,
        where('installment', '!=', null)
      );
      
      const querySnapshot = await getDocs(q);
      const installmentsList = querySnapshot.docs.map(convertToTransaction);
      setInstalledPayments(installmentsList);
    } catch (error) {
      console.error('Erro ao carregar pagamentos parcelados:', error);
    }
  }, [user]);

  // Carregar transa√ß√µes baseadas no m√™s atual
  const loadTransactions = useCallback(async () => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      console.log('üîÑ Carregando transa√ß√µes do Firebase');
      const startOfMonth = new Date(currentMonth.year, currentMonth.month, 1);
      const endOfMonth = new Date(currentMonth.year, currentMonth.month + 1, 0, 23, 59, 59);
      
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      const q = query(
        transactionsCollectionRef,
        where('date', '>=', Timestamp.fromDate(startOfMonth)),
        where('date', '<=', Timestamp.fromDate(endOfMonth))
      );
      
      // Usar onSnapshot para atualiza√ß√£o em tempo real
      return onSnapshot(q, (snapshot) => {
        const transactionsList = snapshot.docs.map(convertToTransaction);
        setTransactions(transactionsList);
        
        // Atualizar resumos baseados nas transa√ß√µes
        updateSummaries(transactionsList);
        
        // Obter pagamentos parcelados
        loadInstallments();
        
        setIsLoading(false);
      }, (error) => {
        console.error('Erro ao observar transa√ß√µes:', error);
        setIsLoading(false);
      });
    } catch (error) {
      console.error('Erro ao carregar transa√ß√µes:', error);
      setIsLoading(false);
    }
  }, [user, currentMonth, loadInstallments]);

  // Carregar m√©todos de pagamento
  const loadPaymentMethods = useCallback(async () => {
    if (!user) return;
    
    try {
      console.log('üîÑ Carregando m√©todos de pagamento do Firebase');
      const methodsCollectionRef = collection(db, 'users', user.id, 'paymentMethods');
      
      // Usar onSnapshot para atualiza√ß√£o em tempo real
      return onSnapshot(methodsCollectionRef, (snapshot) => {
        const methodsList = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as PaymentMethod[];
        
        setPaymentMethods(methodsList);
      }, (error) => {
        console.error('Erro ao observar m√©todos de pagamento:', error);
      });
    } catch (error) {
      console.error('Erro ao carregar m√©todos de pagamento:', error);
    }
  }, [user]);

  // Efeito para carregar dados quando o usu√°rio ou m√™s mudar
  useEffect(() => {
    let unsubscribeTransactions: () => void;
    let unsubscribeAccounts: () => void;
    
    if (user) {
      const loadData = async () => {
        try {
          const unsubTrans = await loadTransactions();
          const unsubAccounts = await loadAccounts();
          const unsubPaymentMethods = await loadPaymentMethods();
          
          if (unsubTrans) unsubscribeTransactions = unsubTrans;
          if (unsubAccounts) unsubscribeAccounts = unsubAccounts;
          if (unsubPaymentMethods) unsubscribeAccounts = unsubPaymentMethods;
        } catch (error) {
          console.error('Erro ao carregar dados:', error);
          setIsLoading(false);
        }
      };
      
      loadData();
    } else {
      // Resetar estados se n√£o houver usu√°rio
      setTransactions([]);
      setAccounts([]);
      setFinancialSummary(initialSummary);
      setCategorySummaries([]);
      setPaymentMethods([]);
    }
    
    // Cleanup
    return () => {
      if (unsubscribeTransactions) unsubscribeTransactions();
      if (unsubscribeAccounts) unsubscribeAccounts();
    };
  }, [user, currentMonth, loadTransactions, loadAccounts, loadPaymentMethods]);

  // Atualizar resumos baseados nas transa√ß√µes
  const updateSummaries = useCallback((transactionsList: Transaction[]) => {
    // Resumo financeiro
    let monthlyIncome = 0;
    let monthlyExpenses = 0;
    let fixedExpenses = 0;
    let variableExpenses = 0;
    let foodVoucherExpenses = 0;  // Adicionar para rastrear despesas com VR
    
    // Categoria summaries
    const categorySummaryMap = new Map<string, Partial<CategorySummary> & {count: number, category?: Category}>();
    
    transactionsList.forEach(transaction => {
      // Atualizando resumo financeiro
      if (transaction.type === TransactionType.INCOME) {
        monthlyIncome += transaction.amount;
      } else if (transaction.type === TransactionType.EXPENSE) {
        monthlyExpenses += transaction.amount;
        
        // Verificar se √© despesa com Vale Refei√ß√£o/Food
        const paymentMethod = paymentMethods.find(m => m.id === transaction.paymentMethodId);
        if (paymentMethod && paymentMethod.type === 'food') {
          foodVoucherExpenses += transaction.amount;
        }
        
        if (transaction.frequency === TransactionFrequency.FIXED) {
          fixedExpenses += transaction.amount;
        } else {
          variableExpenses += transaction.amount;
        }
      }
      
      // Atualizando resumo por categoria
      const categoryId = transaction.categoryId;
      const category = CATEGORIES.find(c => c.id === categoryId);
      
      const categorySummary = categorySummaryMap.get(categoryId) || {
        categoryId,
        category,
        amount: 0,
        count: 0
      };
      
      categorySummary.amount = (categorySummary.amount || 0) + transaction.amount;
      categorySummary.count = (categorySummary.count || 0) + 1;
      categorySummaryMap.set(categoryId, categorySummary);
    });
    
    // Atualizar o resumo financeiro
    setFinancialSummary(prev => ({
      ...prev,
      monthlyIncome,
      monthlyExpenses,
      fixedExpenses,
      variableExpenses,
      foodVoucherExpenses  // Adicionar despesas com VR ao resumo
    }));
    
    // Calcular percentagens e converter o mapa para array
    const total = Math.max(1, Array.from(categorySummaryMap.values())
      .reduce((sum, item) => sum + Math.abs(item.amount || 0), 0));
    
    const categorySummaries: CategorySummary[] = Array.from(categorySummaryMap.values())
      .map(item => ({
        categoryId: item.categoryId || '',
        amount: item.amount || 0,
        percentage: Math.abs(item.amount || 0) / total * 100
      }));
    
    setCategorySummaries(categorySummaries);
  }, [paymentMethods]);

  // Adiciona uma nova transa√ß√£o
  const addTransaction = async (transaction: Omit<Transaction, 'id'>) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      
      // Preparar dados para o Firestore
      const transactionData = {
        ...transaction,
        date: Timestamp.fromDate(transaction.date),
        createdAt: serverTimestamp(),
        installment: transaction.installment ? {
          ...transaction.installment,
          startDate: Timestamp.fromDate(transaction.installment.startDate)
        } : null
      };
      
      console.log(`üîÑ Iniciando adi√ß√£o de transa√ß√£o: ${transaction.description} - Valor: ${transaction.amount} - Tipo: ${transaction.type}`);
      console.log(`üîÑ Categoria: ${transaction.categoryId} - Conta: ${transaction.accountId || 'Nenhuma'}`);
      
      // Verificar se √© uma receita que deve atualizar o saldo de uma conta
      if (
        transaction.type === TransactionType.INCOME && 
        ['salary', 'bonus', 'investment', 'refund'].includes(transaction.categoryId) && 
        transaction.accountId
      ) {
        console.log(`üìù Transa√ß√£o √© uma receita (${transaction.categoryId}) que deve atualizar o saldo da conta ${transaction.accountId}`);
        
        // Atualizar o saldo da conta relacionada
        const accountRef = doc(db, 'users', user.id, 'bankAccounts', transaction.accountId);
        const accountSnap = await getDoc(accountRef);
        
        if (accountSnap.exists()) {
          const accountData = accountSnap.data();
          const currentBalance = accountData.balance || 0;
          const newBalance = currentBalance + transaction.amount;
          
          console.log(`üí∞ Saldo atual da conta "${accountData.name}": ${currentBalance}`);
          console.log(`‚ûï Adicionando valor da transa√ß√£o: ${transaction.amount}`);
          console.log(`üí∞ Novo saldo calculado: ${newBalance}`);
          
          // Atualizar o saldo da conta
          await updateDoc(accountRef, {
            balance: newBalance,
            lastUpdate: serverTimestamp()
          });
          
          console.log(`‚úÖ Saldo da conta ${accountData.name} atualizado: ${currentBalance} + ${transaction.amount} = ${newBalance}`);
          
          // Verifica√ß√£o ap√≥s atualiza√ß√£o
          const verifyAccountSnap = await getDoc(accountRef);
          if (verifyAccountSnap.exists()) {
            const verifyAccountData = verifyAccountSnap.data();
            console.log(`‚úì Verifica√ß√£o: Novo saldo da conta ap√≥s atualiza√ß√£o: ${verifyAccountData.balance}`);
          }
        } else {
          console.error(`‚ùå Conta com ID ${transaction.accountId} n√£o encontrada!`);
        }
      }
      
      // Verificar se √© uma despesa que deve reduzir o saldo de uma conta
      if (
        transaction.type === TransactionType.EXPENSE && 
        transaction.accountId &&
        // N√£o reduzir saldo para compras no cr√©dito
        !(transaction.paymentMethodId && 
        paymentMethods.find(m => m.id === transaction.paymentMethodId)?.type === 'credit')
      ) {
        console.log(`üìù Transa√ß√£o √© uma despesa que deve reduzir o saldo da conta ${transaction.accountId}`);
        
        // Atualizar o saldo da conta relacionada
        const accountRef = doc(db, 'users', user.id, 'bankAccounts', transaction.accountId);
        const accountSnap = await getDoc(accountRef);
        
        if (accountSnap.exists()) {
          const accountData = accountSnap.data();
          const currentBalance = accountData.balance || 0;
          const newBalance = currentBalance - transaction.amount;
          
          console.log(`üí∞ Saldo atual da conta "${accountData.name}": ${currentBalance}`);
          console.log(`‚ûñ Subtraindo valor da transa√ß√£o: ${transaction.amount}`);
          console.log(`üí∞ Novo saldo calculado: ${newBalance}`);
          
          // Atualizar o saldo da conta
          await updateDoc(accountRef, {
            balance: newBalance,
            lastUpdate: serverTimestamp()
          });
          
          console.log(`‚úÖ Saldo da conta ${accountData.name} atualizado: ${currentBalance} - ${transaction.amount} = ${newBalance}`);
          
          // Verifica√ß√£o ap√≥s atualiza√ß√£o
          const verifyAccountSnap = await getDoc(accountRef);
          if (verifyAccountSnap.exists()) {
            const verifyAccountData = verifyAccountSnap.data();
            console.log(`‚úì Verifica√ß√£o: Novo saldo da conta ap√≥s atualiza√ß√£o: ${verifyAccountData.balance}`);
          }
        }
      }
      
      // Adicionar a transa√ß√£o ao Firestore
      const docRef = await addDoc(transactionsCollectionRef, transactionData);
      console.log(`‚úÖ Transa√ß√£o adicionada com sucesso! ID: ${docRef.id}`);
      
      // As atualiza√ß√µes ser√£o feitas pelo listener onSnapshot
    } catch (error) {
      console.error('Erro ao adicionar transa√ß√£o:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Atualiza uma transa√ß√£o existente
  const updateTransaction = async (transaction: Transaction) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      // Primeiro, obter a transa√ß√£o original para comparar valores
      const transactionRef = doc(db, 'users', user.id, 'transactions', transaction.id);
      const transactionSnap = await getDoc(transactionRef);
      
      if (transactionSnap.exists()) {
        const originalTransaction = convertToTransaction(transactionSnap);
        
        // Se houve altera√ß√£o na conta ou valor, precisamos ajustar os saldos
        if (
          // Valor alterado ou conta alterada
          originalTransaction.amount !== transaction.amount ||
          originalTransaction.accountId !== transaction.accountId ||
          originalTransaction.type !== transaction.type ||
          originalTransaction.categoryId !== transaction.categoryId
        ) {
          // 1. Se a transa√ß√£o original era uma receita que afetava uma conta, reverter o incremento
          if (
            originalTransaction.type === TransactionType.INCOME && 
            ['salary', 'bonus', 'investment', 'refund'].includes(originalTransaction.categoryId) && 
            originalTransaction.accountId
          ) {
            const accountRef = doc(db, 'users', user.id, 'bankAccounts', originalTransaction.accountId);
            const accountSnap = await getDoc(accountRef);
            
            if (accountSnap.exists()) {
              const accountData = accountSnap.data();
              const currentBalance = accountData.balance || 0;
              const newBalance = currentBalance - originalTransaction.amount;
              
              // Atualizar o saldo da conta original (reverter o cr√©dito)
              await updateDoc(accountRef, {
                balance: newBalance,
                lastUpdate: serverTimestamp()
              });
              
              console.log(`‚úÖ Revers√£o do cr√©dito na conta ${accountData.name}: ${currentBalance} - ${originalTransaction.amount} = ${newBalance}`);
            }
          }
          
          // 2. Se a transa√ß√£o original era uma despesa que afetava uma conta, reverter a dedu√ß√£o
          if (
            originalTransaction.type === TransactionType.EXPENSE && 
            originalTransaction.accountId &&
            !(originalTransaction.paymentMethodId && 
             paymentMethods.find(m => m.id === originalTransaction.paymentMethodId)?.type === 'credit')
          ) {
            const accountRef = doc(db, 'users', user.id, 'bankAccounts', originalTransaction.accountId);
            const accountSnap = await getDoc(accountRef);
            
            if (accountSnap.exists()) {
              const accountData = accountSnap.data();
              const currentBalance = accountData.balance || 0;
              const newBalance = currentBalance + originalTransaction.amount;
              
              // Atualizar o saldo da conta original (reverter a dedu√ß√£o)
              await updateDoc(accountRef, {
                balance: newBalance,
                lastUpdate: serverTimestamp()
              });
              
              console.log(`‚úÖ Revers√£o da dedu√ß√£o na conta ${accountData.name}: ${currentBalance} + ${originalTransaction.amount} = ${newBalance}`);
            }
          }
          
          // 3. Se a nova transa√ß√£o √© uma receita que afeta uma conta, aplicar o incremento
          if (
            transaction.type === TransactionType.INCOME && 
            ['salary', 'bonus', 'investment', 'refund'].includes(transaction.categoryId) && 
            transaction.accountId
          ) {
            const accountRef = doc(db, 'users', user.id, 'bankAccounts', transaction.accountId);
            const accountSnap = await getDoc(accountRef);
            
            if (accountSnap.exists()) {
              const accountData = accountSnap.data();
              const currentBalance = accountData.balance || 0;
              const newBalance = currentBalance + transaction.amount;
              
              // Atualizar o saldo da nova conta (aplicar o cr√©dito)
              await updateDoc(accountRef, {
                balance: newBalance,
                lastUpdate: serverTimestamp()
              });
              
              console.log(`‚úÖ Cr√©dito aplicado na conta ${accountData.name}: ${currentBalance} + ${transaction.amount} = ${newBalance}`);
            }
          }
          
          // 4. Se a nova transa√ß√£o √© uma despesa que afeta uma conta, aplicar a dedu√ß√£o
          if (
            transaction.type === TransactionType.EXPENSE && 
            transaction.accountId &&
            !(transaction.paymentMethodId && 
             paymentMethods.find(m => m.id === transaction.paymentMethodId)?.type === 'credit')
          ) {
            const accountRef = doc(db, 'users', user.id, 'bankAccounts', transaction.accountId);
            const accountSnap = await getDoc(accountRef);
            
            if (accountSnap.exists()) {
              const accountData = accountSnap.data();
              const currentBalance = accountData.balance || 0;
              const newBalance = currentBalance - transaction.amount;
              
              // Atualizar o saldo da nova conta (aplicar a dedu√ß√£o)
              await updateDoc(accountRef, {
                balance: newBalance,
                lastUpdate: serverTimestamp()
              });
              
              console.log(`‚úÖ Dedu√ß√£o aplicada na conta ${accountData.name}: ${currentBalance} - ${transaction.amount} = ${newBalance}`);
            }
          }
        }
      }
      
      // Atualizar a transa√ß√£o com os novos dados
      await updateDoc(transactionRef, {
        title: transaction.title,
        amount: transaction.amount,
        type: transaction.type,
        categoryId: transaction.categoryId,
        date: Timestamp.fromDate(transaction.date),
        paymentMethodId: transaction.paymentMethodId || null,
        accountId: transaction.accountId || null,
        frequency: transaction.frequency,
        description: transaction.description,
        installment: transaction.installment ? {
          ...transaction.installment,
          startDate: Timestamp.fromDate(transaction.installment.startDate)
        } : null
      });
      
      // As atualiza√ß√µes ser√£o feitas pelo listener onSnapshot
    } catch (error) {
      console.error('Erro ao atualizar transa√ß√£o:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Fun√ß√£o para recalcular o saldo de uma conta baseado no hist√≥rico de transa√ß√µes
  const recalculateAccountBalance = async (accountId: string) => {
    if (!user) return;
    
    try {
      console.log(`üîÑ Recalculando saldo para a conta ${accountId} baseado no hist√≥rico de transa√ß√µes...`);
      
      const accountRef = doc(db, 'users', user.id, 'bankAccounts', accountId);
      const accountSnap = await getDoc(accountRef);
      
      if (!accountSnap.exists()) {
        console.error(`‚ùå Conta com ID ${accountId} n√£o encontrada durante rec√°lculo!`);
        return;
      }
      
      const accountData = accountSnap.data();
      
      // Verificar se a conta tem uma atualiza√ß√£o manual recente (nos √∫ltimos 1 minuto)
      const hasManualUpdate = accountData.manualUpdate === true;
      const lastUpdateTime = accountData.lastUpdate ? accountData.lastUpdate.toDate() : new Date(0);
      const now = new Date();
      const timeDiffInMs = now.getTime() - lastUpdateTime.getTime();
      const isRecentUpdate = timeDiffInMs < 60000; // 1 minuto
      
      if (hasManualUpdate && isRecentUpdate) {
        console.log(`‚ÑπÔ∏è Conta ${accountId} tem uma atualiza√ß√£o manual recente. Respeitando o saldo definido pelo usu√°rio: ${accountData.balance}`);
        return accountData.balance;
      }
      
      // Obter todas as transa√ß√µes relacionadas a esta conta
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      const q = query(
        transactionsCollectionRef,
        where('accountId', '==', accountId)
      );
      
      const querySnapshot = await getDocs(q);
      let calculatedBalance = 0;
      
      // Para cada transa√ß√£o, ajustar o saldo
      querySnapshot.docs.forEach(doc => {
        const transaction = convertToTransaction(doc);
        
        // Receitas que afetam o saldo (sal√°rio, b√¥nus, investimento)
        if (
          transaction.type === TransactionType.INCOME && 
          ['salary', 'bonus', 'investment', 'refund'].includes(transaction.categoryId)
        ) {
          calculatedBalance += transaction.amount;
          console.log(`‚ûï Transa√ß√£o ${transaction.id}: Adicionando ${transaction.amount} (${transaction.title})`);
        }
        
        // Despesas que afetam o saldo (exceto compras no cr√©dito)
        else if (
          transaction.type === TransactionType.EXPENSE &&
          !(transaction.paymentMethodId && 
            paymentMethods.find(m => m.id === transaction.paymentMethodId)?.type === 'credit')
        ) {
          calculatedBalance -= transaction.amount;
          console.log(`‚ûñ Transa√ß√£o ${transaction.id}: Subtraindo ${transaction.amount} (${transaction.title})`);
        }
      });
      
      // Atualizar o saldo da conta
      await updateDoc(accountRef, {
        balance: calculatedBalance,
        lastUpdate: serverTimestamp(),
        manualUpdate: false // Marcar como atualiza√ß√£o autom√°tica
      });
      
      console.log(`‚úÖ Saldo da conta recalculado automaticamente: ${calculatedBalance}`);
      return calculatedBalance;
    } catch (error) {
      console.error('Erro ao recalcular saldo da conta:', error);
      throw error;
    }
  };

  // Exclui uma transa√ß√£o
  const deleteTransaction = async (id: string) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      console.log(`üóëÔ∏è Iniciando exclus√£o de transa√ß√£o: ${id}`);
      
      const transactionRef = doc(db, 'users', user.id, 'transactions', id);
      const transactionSnap = await getDoc(transactionRef);
      
      if (transactionSnap.exists()) {
        const transaction = convertToTransaction(transactionSnap);
        console.log(`üìä Dados da transa√ß√£o a excluir:`, {
          id: transaction.id,
          title: transaction.title,
          amount: transaction.amount,
          type: transaction.type === TransactionType.INCOME ? 'RECEITA' : 'DESPESA',
          categoryId: transaction.categoryId,
          accountId: transaction.accountId
        });
        
        // Verificar se a transa√ß√£o afeta alguma conta
        if (transaction.accountId) {
          // Primeiro, excluir a transa√ß√£o
      await deleteDoc(transactionRef);
          console.log(`‚úÖ Transa√ß√£o exclu√≠da com sucesso`);
          
          // Agora, recalcular o saldo da conta baseado no hist√≥rico atualizado
          await recalculateAccountBalance(transaction.accountId);
        } else {
          // Se n√£o afeta nenhuma conta, apenas excluir
          await deleteDoc(transactionRef);
          console.log(`‚úÖ Transa√ß√£o exclu√≠da com sucesso`);
          console.log(`‚ÑπÔ∏è Transa√ß√£o n√£o estava associada a nenhuma conta, n√£o foi necess√°rio ajustar saldos.`);
        }
      } else {
        console.error(`‚ùå Transa√ß√£o com ID ${id} n√£o encontrada!`);
      }
      
      // As atualiza√ß√µes ser√£o feitas pelo listener onSnapshot
    } catch (error) {
      console.error('Erro ao excluir transa√ß√£o:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Adicionar conta
  const addAccount = async (account: Omit<BalanceAccount, 'id'>) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      const accountsCollectionRef = collection(db, 'users', user.id, 'bankAccounts');
      
      await addDoc(accountsCollectionRef, {
        ...account,
        createdAt: serverTimestamp()
      });
      
      // As atualiza√ß√µes ser√£o feitas pelo listener onSnapshot
    } catch (error) {
      console.error('Erro ao adicionar conta:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Atualizar conta
  const updateAccount = async (account: BalanceAccount) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      console.log(`üîÑ Atualizando conta: ${account.id} - ${account.name}`);
      console.log(`üí∞ Novo saldo definido manualmente: ${account.balance}`);
      
      const accountRef = doc(db, 'users', user.id, 'bankAccounts', account.id);
      
      // Priorizar atualiza√ß√µes manuais do saldo definido pelo usu√°rio
      await updateDoc(accountRef, {
        name: account.name,
        balance: account.balance,
        type: account.type,
        color: account.color,
        icon: account.icon,
        lastUpdate: serverTimestamp(),
        manualUpdate: true // Marcar como atualiza√ß√£o manual
      });
      
      console.log(`‚úÖ Conta atualizada com sucesso. Saldo definido manualmente para: ${account.balance}`);
      
      // As atualiza√ß√µes ser√£o feitas pelo listener onSnapshot
    } catch (error) {
      console.error('Erro ao atualizar conta:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Excluir conta
  const deleteAccount = async (id: string) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      const accountRef = doc(db, 'users', user.id, 'bankAccounts', id);
      await deleteDoc(accountRef);
      
      // As atualiza√ß√µes ser√£o feitas pelo listener onSnapshot
    } catch (error) {
      console.error('Erro ao excluir conta:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Filtros
  const filterTransactionsByCategory = (categoryId: string) => {
    return transactions.filter(t => t.categoryId === categoryId);
  };

  const filterTransactionsByType = (type: TransactionType) => {
    return transactions.filter(t => t.type === type);
  };

  const filterTransactionsByFrequency = (frequency: TransactionFrequency) => {
    return transactions.filter(t => t.frequency === frequency);
  };

  // Mudar m√™s atual
  const changeMonth = (month: number, year: number) => {
    setCurrentMonth({ month, year });
  };

  // Atualizar o resumo financeiro com base nas contas
  const updateAccountBalances = (accountsList: BalanceAccount[]) => {
    let cashBalance = 0;
    let foodVoucherBalance = 0;
    let totalBalance = 0;
    
    accountsList.forEach(account => {
      totalBalance += account.balance;
      
      if (account.type === 'cash' || account.type === 'bank') {
        cashBalance += account.balance;
      } else if (account.type === 'voucher') {
        foodVoucherBalance += account.balance;
      }
    });
    
    // Atualizar o saldo do Vale Refei√ß√£o considerando as despesas
    if (financialSummary.foodVoucherExpenses) {
      foodVoucherBalance -= financialSummary.foodVoucherExpenses;
    }
    
    setFinancialSummary(prev => ({
      ...prev,
      totalBalance,
      cashBalance,
      foodVoucherBalance
    }));
  };

  // Limpar todas as transa√ß√µes (apenas para fins de teste/desenvolvimento)
  const clearTransactions = async () => {
    if (!user) return;
    
    try {
      setIsLoading(true);
      console.log('üóëÔ∏è Limpando todas as transa√ß√µes...');
      
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      const querySnapshot = await getDocs(transactionsCollectionRef);
      
      // Excluir cada documento de transa√ß√£o
      const deletePromises = querySnapshot.docs.map(doc => 
        deleteDoc(doc.ref)
      );
      
      await Promise.all(deletePromises);
      
      // Tamb√©m zerar os saldos de todas as contas banc√°rias
      console.log('üóëÔ∏è Zerando saldos de todas as contas banc√°rias...');
      const accountsCollectionRef = collection(db, 'users', user.id, 'bankAccounts');
      const accountsSnapshot = await getDocs(accountsCollectionRef);
      
      const resetBalancePromises = accountsSnapshot.docs.map(doc => 
        updateDoc(doc.ref, { 
          balance: 0,
          lastUpdate: serverTimestamp()
        })
      );
      
      await Promise.all(resetBalancePromises);
      
      // Recarregar os dados ap√≥s a limpeza
      setTransactions([]);
      updateSummaries([]);
      
      // For√ßar a atualiza√ß√£o das contas no estado local
      const updatedAccounts = accounts.map(account => ({
        ...account,
        balance: 0
      }));
      setAccounts(updatedAccounts);
      updateAccountBalances(updatedAccounts);
      
      console.log('‚úÖ Transa√ß√µes exclu√≠das e saldos de contas zerados com sucesso!');
    } catch (error) {
      console.error('Erro ao limpar transa√ß√µes e zerar saldos:', error);
      setError('Falha ao limpar dados');
    } finally {
      setIsLoading(false);
    }
  };

  // Adicionar uma nova fatura manual
  const addManualBill = async (bills: ManualBill[]) => {
    if (!user) return;
    setIsLoading(true);
    
    try {
      console.log('Iniciando o salvamento de faturas manuais:', bills.length);
      bills.forEach(bill => {
        console.log(`Fatura de ${bill.id}:`, bill.amount, `para ${bill.reference.month + 1}/${bill.reference.year}`);
      });
      
      // Em vez de criar uma nova cole√ß√£o, usaremos a cole√ß√£o 'transactions' existente
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      
      // Criar uma transa√ß√£o para cada fatura manual
      const savePromises = bills
        .filter(bill => bill.amount > 0)
        .map(bill => {
          // Data de refer√™ncia (primeiro dia do m√™s anterior)
          const billDate = new Date(bill.reference.year, bill.reference.month, 1);
          
          // Encontrar o cart√£o correspondente
          const card = paymentMethods.find(method => method.id === bill.id);
          console.log(`Salvando fatura manual para cart√£o: ${card?.name || 'Desconhecido'}, valor: ${bill.amount}`);
          
          const transactionData = {
            title: `Fatura manual: ${card?.name || 'Cart√£o'}`,
            amount: bill.amount,
            type: TransactionType.EXPENSE,
            categoryId: 'bank', // Categoria mudada para 'bank' que √© mais apropriada para faturas de cart√£o
            date: Timestamp.fromDate(billDate),
            paymentMethodId: bill.id,
            frequency: TransactionFrequency.VARIABLE,
            description: `Fatura manual adicionada para ${bill.reference.month + 1}/${bill.reference.year}`,
            isManualBill: true, // Marcar como fatura manual
            createdAt: serverTimestamp()
          };
          
          console.log('Dados da transa√ß√£o a ser salva:', JSON.stringify(transactionData));
          return addDoc(transactionsCollectionRef, transactionData);
        });
      
      if (savePromises.length === 0) {
        throw new Error('Nenhuma fatura com valor v√°lido para salvar');
      }
      
      const results = await Promise.all(savePromises);
      
      console.log(`‚úÖ Salvas ${results.length} faturas manuais como transa√ß√µes com IDs:`);
      results.forEach((docRef, index) => {
        console.log(`Fatura #${index + 1} ID: ${docRef.id}`);
      });

      // Verificar se as faturas foram salvas corretamente
      const checkPromises = results.map(async (docRef) => {
        const docSnap = await getDoc(docRef);
        console.log(`Verificando documento ${docRef.id}:`, docSnap.exists() ? 'Existe' : 'N√£o existe');
        if (docSnap.exists()) {
          const data = docSnap.data();
          console.log(`Documento ${docRef.id} dados:`, {
            title: data.title,
            amount: data.amount,
            isManualBill: data.isManualBill === true ? 'true' : 'false ou undefined',
            date: data.date?.toDate?.() || data.date,
            paymentMethodId: data.paymentMethodId
          });
          
          // Se isManualBill n√£o estiver definido, vamos corrigir
          if (data.isManualBill !== true) {
            console.log(`Corrigindo isManualBill para ${docRef.id}`);
            await updateDoc(docRef, { isManualBill: true });
          }
        }
      });
      
      await Promise.all(checkPromises);
      console.log('Verifica√ß√£o de documentos conclu√≠da');

      // Recarregar todas as transa√ß√µes ap√≥s adicionar faturas manuais
      // Este passo √© importante para garantir que as novas faturas sejam exibidas
      await reloadAllTransactions();
      
    } catch (error) {
      console.error('Erro ao adicionar fatura manual:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Fun√ß√£o auxiliar para recarregar todas as transa√ß√µes (incluindo meses anteriores)
  const reloadAllTransactions = async () => {
    if (!user) return;
    
    try {
      console.log('üîÑ Recarregando todas as transa√ß√µes para atualizar faturas manuais...');
      const transactionsCollectionRef = collection(db, 'users', user.id, 'transactions');
      
      // Buscar todas as transa√ß√µes sem filtro de data
      const snapshot = await getDocs(transactionsCollectionRef);
      const allTransactions = snapshot.docs.map(convertToTransaction);
      
      console.log(`Total de transa√ß√µes carregadas: ${allTransactions.length}`);
      
      // Filtrar transa√ß√µes do m√™s atual para atualizar o estado
      const startOfMonth = new Date(currentMonth.year, currentMonth.month, 1);
      const endOfMonth = new Date(currentMonth.year, currentMonth.month + 1, 0, 23, 59, 59);
      
      const currentMonthTransactions = allTransactions.filter(transaction => {
        const transactionDate = transaction.date;
        return transactionDate >= startOfMonth && transactionDate <= endOfMonth;
      });
      
      // Filtrar transa√ß√µes do m√™s anterior para debug
      const prevMonth = currentMonth.month - 1 < 0 ? 11 : currentMonth.month - 1;
      const prevYear = currentMonth.month - 1 < 0 ? currentMonth.year - 1 : currentMonth.year;
      const startOfPrevMonth = new Date(prevYear, prevMonth, 1);
      const endOfPrevMonth = new Date(prevYear, prevMonth + 1, 0, 23, 59, 59);
      
      const prevMonthTransactions = allTransactions.filter(transaction => {
        const transactionDate = transaction.date;
        return transactionDate >= startOfPrevMonth && transactionDate <= endOfPrevMonth;
      });
      
      // Verificando faturas manuais do m√™s anterior
      const manualBills = prevMonthTransactions.filter(t => t.isManualBill === true);
      console.log(`Encontradas ${manualBills.length} faturas manuais do m√™s anterior ap√≥s recarga`);
      manualBills.forEach(bill => {
        console.log(`Fatura manual: ID: ${bill.id}, t√≠tulo: ${bill.title}, valor: ${bill.amount}, data: ${bill.date.toLocaleDateString()}, m√©todo: ${bill.paymentMethodId}, isManualBill: ${bill.isManualBill}`);
      });
      
      // Armazenar todas as transa√ß√µes em uma vari√°vel de contexto para acesso global
      if (window) {
        (window as any).__allTransactions = allTransactions;
        console.log('Todas as transa√ß√µes foram armazenadas na vari√°vel global __allTransactions para debug');
      }
      
      // Atualizar o estado das transa√ß√µes do m√™s atual
      setTransactions(currentMonthTransactions);
      
      // Atualizar resumos baseados nas transa√ß√µes
      updateSummaries(currentMonthTransactions);
      
      console.log('‚úÖ Transa√ß√µes recarregadas com sucesso');
      
      return allTransactions;
    } catch (error) {
      console.error('Erro ao recarregar transa√ß√µes:', error);
      throw error;
    }
  };

  return (
    <TransactionContext.Provider value={{
      currentMonth,
      transactions,
      financialSummary,
      categorySummaries,
      accounts,
      installedPayments,
      paymentMethods,
      isLoading,
      error,
      addTransaction,
      updateTransaction,
      deleteTransaction,
      filterTransactionsByCategory,
      filterTransactionsByType,
      filterTransactionsByFrequency,
      changeMonth,
      addAccount,
      updateAccount,
      deleteAccount,
      loadAccounts,
      loadPaymentMethods,
      clearTransactions,
      addManualBill
    }}>
      {children}
    </TransactionContext.Provider>
  );
}

export const useTransactions = () => {
  const context = useContext(TransactionContext);
  if (!context) {
    throw new Error('useTransactions deve ser usado dentro de um TransactionProvider');
  }
  return context;
}; 